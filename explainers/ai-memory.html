<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>How AI Memory Works — Visual Explainer</title>
<script src="https://unpkg.com/react@18/umd/react.development.js"></script>
<script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
<script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
<style>*{box-sizing:border-box;margin:0;padding:0}body{background:#f8f8f6}</style>
</head><body><div id="root"></div>
<script type="text/babel">
const { useState } = React;
const C = { bg:"#f8f8f6",card:"#fff",border:"#e5e5e0",text:"#222",sub:"#666",muted:"#999",accent:"#ea580c",blue:"#0891b2",purple:"#7c3aed",green:"#16a34a",amber:"#ca8a04",red:"#dc2626" };
const font = { heading:"'Space Grotesk', sans-serif", body:"'IBM Plex Sans', sans-serif", mono:"'JetBrains Mono', monospace" };
const Card = ({ children, style, accent, onClick }) => (
  <div onClick={onClick} style={{background:C.card,border:`1px solid ${C.border}`,borderRadius:4,padding:20,position:"relative",overflow:"hidden",boxShadow:"0 1px 3px rgba(0,0,0,0.04)",cursor:onClick?"pointer":"default",...style}}>
    {accent && <div style={{position:"absolute",top:0,left:0,right:0,height:3,background:accent}}/>}
    {children}
  </div>
);
const Tag = ({ color, children }) => <span style={{fontFamily:font.mono,fontSize:11,color,background:`${color}12`,border:`1px solid ${color}30`,padding:"2px 10px",borderRadius:3,letterSpacing:0.5,display:"inline-block"}}>{children}</span>;
const H3 = ({ children, color }) => <h3 style={{fontFamily:font.heading,fontSize:16,fontWeight:700,color:color||C.text,margin:"0 0 8px"}}>{children}</h3>;
const P = ({ children, style }) => <p style={{fontFamily:font.body,fontSize:13.5,color:C.sub,lineHeight:1.65,margin:0,...style}}>{children}</p>;

const MEMORY_TYPES = [
  { id:"context", label:"In-Context Memory", color:C.blue,
    what:"Everything in the current conversation window — messages, files, system instructions.",
    how:"The model reads the entire context on every response. Nothing is 'retrieved' — it's all just there.",
    limit:"Fixed window size (e.g. 200k tokens). Older content may be truncated. Disappears when the session ends.",
    analogy:"Working memory / RAM — fast, immediate, but finite and volatile.",
    score:{ speed:5, capacity:2, persistence:1 } },
  { id:"external", label:"External Memory (RAG)", color:C.purple,
    what:"A searchable database of documents, notes, or past conversations stored outside the model.",
    how:"A retrieval system finds the most relevant chunks at query time and injects them into context.",
    limit:"Retrieval quality depends on the search. Irrelevant chunks waste context. Slow compared to in-context.",
    analogy:"A library with a librarian — you ask, they fetch the relevant book, you read the relevant page.",
    score:{ speed:3, capacity:5, persistence:5 } },
  { id:"parametric", label:"Parametric Memory", color:C.amber,
    what:"Knowledge baked into model weights during training — facts, language, reasoning patterns.",
    how:"Not retrieved at runtime. The model 'knows' it the same way you know how to ride a bike.",
    limit:"Static after training. Can be wrong, outdated, or hallucinated. Can't be updated without retraining.",
    analogy:"Long-term memory — things you just know, deeply ingrained, but possibly incorrect.",
    score:{ speed:5, capacity:3, persistence:5 } },
  { id:"episodic", label:"Episodic / Tool Memory", color:C.green,
    what:"Structured logs of past interactions, decisions, or task outcomes stored in a database or file.",
    how:"The agent writes summaries or key facts to storage after each session. Future sessions load relevant memories.",
    limit:"Requires explicit design. Quality depends on what gets written and how it's retrieved.",
    analogy:"A notebook — what you consciously chose to write down and can look up later.",
    score:{ speed:3, capacity:4, persistence:5 } },
];

const TRADEOFFS = [
  { dim:"Speed", desc:"How fast is the memory accessible?", winner:"In-context & Parametric (always loaded)", loser:"External (requires retrieval round-trip)" },
  { dim:"Capacity", desc:"How much can be stored?", winner:"External RAG (virtually unlimited)", loser:"In-context (bounded by window size)" },
  { dim:"Persistence", desc:"Does it survive session end?", winner:"External & Parametric (durable)", loser:"In-context (lost when session closes)" },
  { dim:"Accuracy", desc:"How precisely is the right info found?", winner:"In-context (everything visible at once)", loser:"External (retrieval may miss key chunks)" },
  { dim:"Updatability", desc:"Can you add new info without retraining?", winner:"External & Episodic (add docs anytime)", loser:"Parametric (frozen in weights)" },
];

function Bar({ value, max=5, color }) {
  return (
    <div style={{display:"flex",gap:3,alignItems:"center"}}>
      {Array.from({length:max}).map((_,i) => (
        <div key={i} style={{width:14,height:8,borderRadius:2,background:i<value?color:`${color}20`}}/>
      ))}
    </div>
  );
}

function SectionProblem() {
  return (
    <div style={{display:"flex",flexDirection:"column",gap:16}}>
      <Card accent={C.accent}>
        <div style={{paddingTop:8}}>
          <Tag color={C.accent}>THE CHALLENGE</Tag>
          <P style={{marginTop:12,fontSize:15,color:C.text,fontWeight:500,lineHeight:1.7}}>
            A language model has no persistent memory by default. Every conversation starts fresh — it doesn't know who you are, what you discussed last time, or what's in your company's documents. Memory systems are how we fix this.
          </P>
        </div>
      </Card>
      <div style={{display:"grid",gridTemplateColumns:"1fr 1fr",gap:16}}>
        <Card>
          <H3 color={C.red}>Without memory</H3>
          <P>Every session starts blank. You re-explain context every time. The model can't personalise or build on past work. Long documents can't be referenced.</P>
        </Card>
        <Card>
          <H3 color={C.green}>With memory</H3>
          <P>The AI knows your preferences, past decisions, and domain knowledge. It can reference documents you've loaded and pick up where it left off.</P>
        </Card>
      </div>
      <Card style={{background:`${C.purple}06`,border:`1px solid ${C.purple}20`}}>
        <Tag color={C.purple}>KEY INSIGHT</Tag>
        <P style={{marginTop:8}}>There's no single "memory" in AI — there are four distinct types, each with different properties. Practical systems layer multiple types together to get the right trade-offs.</P>
      </Card>
    </div>
  );
}

function SectionTypes() {
  const [active, setActive] = useState(0);
  const m = MEMORY_TYPES[active];
  return (
    <div style={{display:"flex",flexDirection:"column",gap:16}}>
      <div style={{display:"flex",gap:8,flexWrap:"wrap"}}>
        {MEMORY_TYPES.map((mt,i) => (
          <button key={i} onClick={() => setActive(i)} style={{fontFamily:font.heading,fontSize:12,fontWeight:active===i?700:500,color:active===i?mt.color:C.sub,background:active===i?`${mt.color}08`:"transparent",border:`1px solid ${active===i?`${mt.color}30`:"transparent"}`,borderRadius:4,padding:"8px 14px",cursor:"pointer",transition:"all 0.2s"}}>{mt.label.split(" ")[0]}</button>
        ))}
      </div>
      <Card accent={m.color} style={{border:`2px solid ${m.color}30`}}>
        <div style={{paddingTop:8}}>
          <Tag color={m.color}>{m.label.toUpperCase()}</Tag>
          <div style={{display:"grid",gridTemplateColumns:"1fr 1fr",gap:12,marginTop:14}}>
            <div style={{padding:12,background:`${m.color}05`,border:`1px solid ${m.color}15`,borderRadius:4}}>
              <div style={{fontFamily:font.mono,fontSize:10,color:m.color,textTransform:"uppercase",letterSpacing:1,marginBottom:6}}>WHAT IS IT</div>
              <P style={{fontSize:12.5}}>{m.what}</P>
            </div>
            <div style={{padding:12,background:`${m.color}05`,border:`1px solid ${m.color}15`,borderRadius:4}}>
              <div style={{fontFamily:font.mono,fontSize:10,color:m.color,textTransform:"uppercase",letterSpacing:1,marginBottom:6}}>HOW IT WORKS</div>
              <P style={{fontSize:12.5}}>{m.how}</P>
            </div>
          </div>
          <div style={{marginTop:12,padding:12,background:`${C.red}05`,border:`1px solid ${C.red}15`,borderRadius:4}}>
            <div style={{fontFamily:font.mono,fontSize:10,color:C.red,textTransform:"uppercase",letterSpacing:1,marginBottom:6}}>LIMITATION</div>
            <P style={{fontSize:12.5}}>{m.limit}</P>
          </div>
          <div style={{marginTop:12,padding:12,background:"#f4f4f0",border:`1px solid ${C.border}`,borderRadius:4}}>
            <div style={{fontFamily:font.mono,fontSize:10,color:C.muted,textTransform:"uppercase",letterSpacing:1,marginBottom:6}}>ANALOGY</div>
            <P style={{fontSize:12.5,color:C.text,fontStyle:"italic"}}>{m.analogy}</P>
          </div>
          <div style={{marginTop:14,display:"flex",gap:24}}>
            {Object.entries(m.score).map(([k,v]) => (
              <div key={k}>
                <div style={{fontFamily:font.mono,fontSize:10,color:C.muted,textTransform:"uppercase",letterSpacing:1,marginBottom:6}}>{k}</div>
                <Bar value={v} color={m.color}/>
              </div>
            ))}
          </div>
        </div>
      </Card>
    </div>
  );
}

function SectionHowItWorks() {
  const [step, setStep] = useState(0);
  const steps = [
    { title:"User sends a message", detail:"The prompt enters the pipeline. Before reaching the model, a memory router decides what additional context to fetch.", color:C.blue },
    { title:"Retrieval (if needed)", detail:"For external memory, the query is embedded as a vector and compared against stored document chunks. The top-K most similar are retrieved.", color:C.purple },
    { title:"Context assembly", detail:"Retrieved chunks + conversation history + system instructions are assembled into the full context window that the model will read.", color:C.amber },
    { title:"Model generates response", detail:"The model reads the assembled context — all the 'memory' at once — and produces its response based on the full picture.", color:C.green },
    { title:"Memory update (optional)", detail:"After the response, an episodic system may write a summary of what happened to durable storage, for future sessions to load.", color:C.accent },
  ];
  return (
    <div style={{display:"flex",flexDirection:"column",gap:12}}>
      <P style={{marginBottom:4}}>How a production RAG + episodic memory pipeline works step by step.</P>
      <div style={{display:"flex",gap:6,flexWrap:"wrap",marginBottom:8}}>
        {steps.map((s,i) => (
          <button key={i} onClick={() => setStep(i)} style={{fontFamily:font.mono,fontSize:11,color:step===i?"#fff":s.color,background:step===i?s.color:`${s.color}12`,border:`1px solid ${s.color}30`,borderRadius:3,padding:"4px 12px",cursor:"pointer",transition:"all 0.2s"}}>{i+1}</button>
        ))}
      </div>
      <Card accent={steps[step].color} style={{border:`2px solid ${steps[step].color}30`}}>
        <div style={{paddingTop:8}}>
          <Tag color={steps[step].color}>STEP {step+1} OF {steps.length}</Tag>
          <H3 style={{marginTop:10}} color={steps[step].color}>{steps[step].title}</H3>
          <P>{steps[step].detail}</P>
        </div>
      </Card>
    </div>
  );
}

function SectionTradeoffs() {
  const [open, setOpen] = useState(null);
  return (
    <div style={{display:"flex",flexDirection:"column",gap:12}}>
      <P style={{marginBottom:4}}>Every memory design involves trade-offs. Click a dimension to understand the tension.</P>
      {TRADEOFFS.map((t,i) => (
        <Card key={i} onClick={() => setOpen(open===i?null:i)}
          style={{border:open===i?`2px solid ${C.purple}`:`1px solid ${C.border}`,padding:open===i?"16px 19px":20,transition:"all 0.2s"}}>
          <div style={{display:"flex",alignItems:"center",gap:12}}>
            <H3 color={open===i?C.purple:C.text}>{t.dim}</H3>
            <P style={{fontSize:12,marginLeft:4}}>{t.desc}</P>
            <span style={{fontFamily:font.mono,fontSize:11,color:C.muted,marginLeft:"auto"}}>{open===i?"▲":"▼"}</span>
          </div>
          {open===i && (
            <div style={{marginTop:12,display:"grid",gridTemplateColumns:"1fr 1fr",gap:12}}>
              <div style={{padding:12,background:`${C.green}05`,border:`1px solid ${C.green}15`,borderRadius:4}}>
                <div style={{fontFamily:font.mono,fontSize:10,color:C.green,textTransform:"uppercase",letterSpacing:1,marginBottom:6}}>WINS</div>
                <P style={{fontSize:12.5}}>{t.winner}</P>
              </div>
              <div style={{padding:12,background:`${C.red}05`,border:`1px solid ${C.red}15`,borderRadius:4}}>
                <div style={{fontFamily:font.mono,fontSize:10,color:C.red,textTransform:"uppercase",letterSpacing:1,marginBottom:6}}>STRUGGLES</div>
                <P style={{fontSize:12.5}}>{t.loser}</P>
              </div>
            </div>
          )}
        </Card>
      ))}
    </div>
  );
}

export default function MemoryExplainer() {
  const [tab, setTab] = useState(0);
  const TABS = ["The Problem","Memory Types","How It Works","Trade-offs"];
  const sections = [<SectionProblem/>,<SectionTypes/>,<SectionHowItWorks/>,<SectionTradeoffs/>];
  return (
    <div style={{background:C.bg,minHeight:"100vh",fontFamily:font.body,color:C.text}}>
      <link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;500;600;700&family=IBM+Plex+Sans:wght@400;500;600&family=JetBrains+Mono:wght@400;500;600&display=swap" rel="stylesheet"/>
      <div style={{padding:"32px 24px 0",maxWidth:800,margin:"0 auto"}}>
        <span style={{fontFamily:font.mono,fontSize:11,color:C.accent,background:`${C.accent}10`,padding:"2px 10px",borderRadius:3,letterSpacing:2,textTransform:"uppercase"}}>Visual Explainer</span>
        <h1 style={{fontFamily:font.heading,fontSize:30,fontWeight:700,color:C.text,margin:"8px 0 4px",lineHeight:1.2,letterSpacing:-0.5}}>How AI Memory Works</h1>
        <P>The four types of memory in AI systems, how they're layered together, and the trade-offs that every design must navigate.</P>
      </div>
      <div style={{maxWidth:800,margin:"20px auto 0",padding:"0 24px",display:"flex",gap:4,flexWrap:"wrap"}}>
        {TABS.map((t,i) => (<button key={i} onClick={() => setTab(i)} style={{fontFamily:font.heading,fontSize:12,fontWeight:tab===i?700:500,color:tab===i?C.accent:C.sub,background:tab===i?`${C.accent}08`:"transparent",border:`1px solid ${tab===i?`${C.accent}30`:"transparent"}`,borderRadius:4,padding:"8px 14px",cursor:"pointer",transition:"all 0.2s"}}>{t}</button>))}
      </div>
      <div style={{maxWidth:800,margin:"16px auto 40px",padding:"0 24px"}}>{sections[tab]}</div>
      <div style={{maxWidth:800,margin:"0 auto",padding:"16px 24px 32px",borderTop:`1px solid ${C.border}`}}>
        <P style={{fontSize:11,color:C.muted,textAlign:"center"}}><a href="claude-cowork.html" style={{color:C.accent,textDecoration:"none"}}>← Claude Cowork</a> · <a href="index.html" style={{color:C.accent,textDecoration:"none"}}>AI Concepts Series</a> · <a href="agentic-system.html" style={{color:C.accent,textDecoration:"none"}}>Agentic Systems →</a></P>
      </div>
    </div>
  );
}
ReactDOM.createRoot(document.getElementById('root')).render(<MemoryExplainer/>);
</script></body></html>
